# 프로세스와 스레드

---

### 1. 프로세스와 스레드는 무엇일까?

컴퓨터가 프로그램을 실행할 때, 두 가지 개념이 등장함.

- 프로세스(Process): 실행 중인 프로그램
- 스레드(Thread): 프로세스 안에서 실행되는 작은 작업 단위


예시: "엑셀(Excel)" 프로그램을 실행하는 경우

- 엑셀 하나가 프로세스
- 엑셀에서 여러 개의 파일을 동시에 편집하면, 각 편집 작업이 스레드
- 즉, 하나의 프로세스 안에는 여러 개의 스레드가 있을 수 있음.




#### 2. 프로세스와 스레드의 차이점

프로세스와 스레드는 메모리를 사용하는 방식에서 차이가 있다고 함.

- 프로세스(Process)
    - 각각 독립적인 메모리를 사용
    - 다른 프로세스와 영향을 주고 받지 않음
    - 독립적이기 때문에 속도가 느릴 수 있다.
    - 각각 독립적으로 실행되는 프로그램이라고 볼 수 있음.

- 스레드(Thread)
    - 같은 프로세스의 메모리를 공유함
    - 한 스레드의 오류가 전체에 영향을 준다고 함.
    - 같은 공간을 공유하므로 속도가 빠르다고 함.
    - 같은 프로그램 안에서 여러 개의 작은 작업을 동시에 실행하는 경우라고 볼 수 있음.




### 3. 프로세스가 메모리를 어떻게 사용할까?

- 컴퓨터에서 프로세스가 실행될 때, 4가지 주요 메모리 영역을 사용

프로세스의 메모리 구조

1. 코드(Code) 영역: 프로그램의 명령어(실행 코드)가 저장되는 공간

2. 데이터(Data) 영역: 프로그램이 사용하는 전역 변수, 배열, 상수 등이 저장됨

3. 힙(Heap) 영역: 실행 도중 동적으로 생성되는 데이터를 저장 (예: new() 또는 malloc())

4. 스택(Stack) 영역: 함수 호출 시 사용되는 지역 변수, 매개 변수, 리턴 값 등을 저장
    - 프로세스는 완전히 각각 독립적인 메모리를 할당 받음.
    - 스레드는 Heap, Data, Code 영역을 공유하나 Stack은 따로 할당받는다고 함.
    - 각 스레드는 독립적인 작업을 수행해야 하기 때문에, 함수 호출과 관련된 정보는 따로 저장해야 하기 때문에 스택은 따로 받는다고 함.

5. 멀티프로세스 vs 멀티스레드

병렬로 여러 작업을 동시에 실행시키기 위해서 사용하는 두가지 기법이 멀티 프로세스 혹은 멀티 스레드임. 

- 멀티 프로세스: 하나의 프로그램을 여러 개의 프로세스로 나누어 실행하는 것
    - 장점: 안전성이 높음 (각 프로세스가 독립적)
    - 단점: 속도가 느릴 수 있음 (각각의 프로세스가 독립된 메모리를 사용)

- 멀티 스레드: 하나의 프로그램을 여러 개의 스레드로 나누어 실행하는 것
    - 장점: 속도가 빠름 (공유 메모리를 사용)
    - 단점: 하나의 스레드가 문제가 생기면, 전체 프로그램에 영향을 줄 수 있음

- Context Switching
    - 멀티프로세스 환경에서는 CPU가 여러 프로세스를 번갈아 가면서 실행함
    - 이때, 작업을 바꾸기 위해 저장하고 불러오는 과정을 Context Switching이라고 해요.

- Context Switching 과정
    - 현재 실행 중인 프로세스의 상태를 저장
    - 새로운 프로세스를 실행하면서 이전 상태를 복구
    - 단점: 프로세스 간 전환이 많아지면 성능이 저하될 수 있음

- 멀티스레드에서 발생하는 문제 (Critical Section)
    - 멀티스레드는 같은 메모리를 공유하기 때문에, 동시에 같은 데이터를 수정할 경우 문제가 발생할 수도 있다.
    - 이를 해결하기 위해 Critical Section(임계 영역) 기법이 필요하다고 함.

- Critical Section 기법
    - 여러 스레드가 같은 데이터를 수정할 때, 하나의 스레드만 접근하도록 제한하는 기술
    - Lock, Semaphore 등을 사용하여 해결




### 4. 정리

- 프로세스: 실행 중인 프로그램 (독립적인 메모리 사용)

- 스레드: 프로세스 내부에서 실행되는 작은 작업 단위 (메모리 공유)

- 멀티프로세스: 여러 개의 독립적인 프로세스를 실행 (안정적이지만 느림)

- 멀티스레드: 하나의 프로세스 내에서 여러 개의 스레드 실행 (빠르지만 불안정)

- Context Switching: 멀티 프로세스에서 프로세스를 전환하는 과정 (오버헤드 발생 가능)

- Critical Section: 여러 스레드가 같은 데이터를 수정할 때 발생하는 문제 해결




### 5. 추가 - 파이썬에서 멀티 스레딩과 멀티 프로세싱


1. 파이썬에서 멀티스레딩과 멀티프로세싱을 사용하는 이유

- 파이썬에서는 병렬 처리를 할 때 멀티스레딩보다 멀티프로세싱을 많이 사용한다고 함.

- 그 이유는 GIL(Global Interpreter Lock) 때문이에요.


2. GIL(Global Interpreter Lock) 이란?

- 파이썬은 한 번에 하나의 스레드만 실행할 수 있도록 제한하는 락(lock)이 있고, 이를 **GIL(Global Interpreter Lock)** 이라고 한다고 함.

- 파이썬의 메모리 관리 시스템이 **Thread-Safe(스레드 간 안전한 동작)** 하도록 하기 위해, 여러 스레드가 같은 객체를 수정할 때 충돌을 방지하기 위해서 도입되었다고 함.

- 이에 의해 멀티스레딩의 이점이 제한됨 → 여러 개의 스레드를 사용해도 한 번에 하나씩만 실행됨

- CPU 연산이 많은 작업에서는 오히려 느림 → 병렬 처리가 제대로 안 됨

- 즉, 파이썬에서는 멀티스레딩이 병렬 처리를 하지 못하고, 오히려 순차적으로 실행됨


3. 멀티 스레딩 vs 멀티 프로세싱 in Python

- 멀티 스레딩(Thread)
    - 메모리 공유: 공유됨
    - CPU 연산 처리: GIL 때문에 제약
    - I/O 작업 처리: 효과적 (파일, 네트워크)
    - 안정성: 하나의 스레드가 죽으면 전체 영향을 받을 수 있음
    - 속도: GIL 때문에 CPU 작업에서 느림

- 멀티 프로세싱(Process)
    - 메모리 공유: 독립적
    - CPU 연산 처리: GIL 영향을 받지 않음
    - I/O 작업 처리: 효과적이지 않음
    - 안정성: 독립적으로 실행되므로 안정적
    - 속도: 여러 개의 코어를 활용해 병렬 실행 가능

- 즉, 파이썬에서 CPU 작업이 많은 경우는 멀티프로세싱을, I/O 작업이 많은 경우는 멀티스레딩을 사용한다.
    - CPU 연산 (수학 계산, 이미지 처리, 머신러닝 연산 등): 멀티 프로세싱이 적합, GIL 때문에 멀티 스레드는 CPU를 효율적으로 사용하지 못함
    - I/O 작업 (파일 읽기/쓰기, 네트워크 요청, 웹 크롤링): 멀티스레딩이 적합, 스레드 간 메모리를 공유하며 대기 시간 동안 다른 스레드가 실행 가능
    - 데이터베이스 쿼리 처리: 멀티스레딩이 적합, 쿼리를 실행하는 동안 CPU가 대기하는 시간이 많으므로 유리함


4. 멀티스레딩 예제 

```python
import threading
import time

# GIL의 영향을 받지만, I/O 대기 시간이 길기 때문에 병렬 실행 효과를 볼 수 있음
def task(name):
    print(f"{name} 시작")
    time.sleep(2)  # 네트워크 요청, 파일 읽기 등의 작업을 가정
    print(f"{name} 완료")

# 스레드 생성
t1 = threading.Thread(target=task, args=("스레드 1",))
t2 = threading.Thread(target=task, args=("스레드 2",))

# 스레드 실행
t1.start()
t2.start()

# 스레드가 끝날 때까지 대기
t1.join()
t2.join()

print("모든 스레드 완료")
```


5. 멀티프로세싱 예제

```python
import multiprocessing

# GIL을 우회할 수 있기 때문에 여러 코어를 활용하여 CPU 연산을 병렬로 실행 가능
def task(n):
    return sum(i * i for i in range(n))

if __name__ == "__main__":
    num_list = [10**6, 10**6, 10**6, 10**6]

    # Pool을 이용한 병렬 실행
    with multiprocessing.Pool(processes=4) as pool:
        results = pool.map(task, num_list)

    print(results)
```

