# 명령어 사이클 (Instruction Cycle)

- 컴퓨터가 명령어를 실행하는 과정을 명령어 사이클(Instruction Cycle)이라고 함 => CPU는 이 사이클을 반복하면서 연산을 수행




### 1. 명령어 사이클 (Instruction Cycle)

- 명령어 사이클은 크게 세 단계(Fetch, Decode, Execute)로 나뉨

- 각 단계에서 CPU 내부의 레지스터(Register)들이 협력해서 작업을 수행

1. Fetch Cycle (명령어 인출)
2. Decode Cycle (명령어 해독)
3. Execute Cycle (명령어 실행)

- 이 과정은 반복적으로 수행되며, CPU가 프로그램을 실행하는 핵심적인 흐름이 됨.




### 2. 주요 레지스터 역할

- CPU에는 여러 개의 레지스터가 있는데, 각각 중요한 역할을 함

- 레지스터 / 설명
    - PC (Program Counter): 다음 실행할 명령어의 메모리 주소를 저장
    - MAR (Memory Address Register): 읽거나 쓸 메모리 주소를 저장
    - MBR (Memory Buffer Register): 메모리에서 읽어온 데이터 또는 저장할 데이터를 임시 저장
    - IR (Instruction Register): 현재 실행 중인 명령어(opcode) 저장
    - ALU (Arithmetic Logic Unit): 산술연산(+, -, *, /) 및 논리연산(AND, OR, NOT) 수행

- 쉽게 말해서,
    - PC는 다음 명령어의 위치를 가리키고
    - MAR은 메모리 주소를
    - MBR은 데이터를
    - IR은 현재 실행 중인 명령어를 보관하는 역할




### 3. Fetch Cycle (명령어 가져오기)

- Fetch(인출) 단계에서는 CPU가 메모리에서 실행할 명령어를 가져오는 작업을 함.
    - 이 과정이 끝나야 명령어를 해석하고 실행할 수 있음.

1. PC(프로그램 카운터)에 저장된 주소를 MAR로 보냄
    - PC는 "다음에 실행할 명령어가 저장된 메모리 주소"를 갖고 있음.
    - 이 주소를 MAR로 복사해서, "이 주소의 데이터를 읽겠다"라고 CPU가 준비

2. MAR에 저장된 주소에서 실제 명령어(Opcode)를 읽어 MBR에 저장
    - MAR이 지정한 메모리 주소에서 명령어를 가져와서 MBR(메모리 버퍼 레지스터)에 저장

3. MBR에 저장된 명령어를 IR(명령어 레지스터)로 이동
    - MBR에 임시 저장된 명령어(Opcode)를 IR(명령어 레지스터)로 옮겨서 CPU가 해석할 준비를 함.

4. PC 값을 증가 (PC = PC + 1)
    - 다음 명령어를 실행하기 위해 PC 값을 증가시켜, 다음 실행할 명령어의 위치를 가리키게 함.

- 위 과정의 결과,
    - CPU는 명령어를 메모리에서 가져와 IR(명령어 레지스터)에 저장함
    - 이제 CPU는 Decode 단계에서 이 명령어를 분석하고 해석할 수 있음.




### 4. Decode Cycle (명령어 해독)

- 이제 CPU는 가져온 명령어를 분석해서 무슨 작업을 해야 하는지 해석함.
    - 즉 IR에 저장된 명령어를 해독하는 단계임

1. IR(명령어 레지스터)에서 Opcode(명령어 코드)를 확인
    - 명령어는 보통 두 부분으로 구성됨.
        - Opcode (연산 코드): 실행할 작업을 정의 (예: 더하기, 곱하기, 데이터 이동 등)
        - Operand (연산 대상): 사용할 데이터나 메모리 주소

3. 해석된 명령어를 ALU 또는 특정 장치에 전달
    - CPU는 이 명령어가 연산(산술, 논리)인지, 메모리 접근인지, 제어 흐름 명령어(점프, 조건문)인지 판단함.

- 위 과정의 결과, CPU는 명령어를 해석하고 어떤 동작을 수행해야 하는지 결정함. => 이제 실행 단계로 넘어가서 명령어를 수행함.




### 5. Execute Cycle (명령어 실행)

- 이 단계에서는 실제로 연산을 수행하거나 메모리에 데이터를 읽고 쓰는 작업을 하게 됨.

1. ALU(산술 논리 연산 장치)가 연산을 수행
    - 만약 명령어가 산술 연산`(+, -, *, /)`이라면 ALU에서 수행
    - 논리 연산(AND, OR, NOT)도 여기서 처리

2. 메모리에서 데이터를 읽거나 저장
    - 만약 메모리에서 값을 가져오거나 저장하는 명령어라면, MAR & MBR을 사용해서 메모리 접근을 수행

3. 결과를 다시 저장
    - 연산 결과를 레지스터 또는 메모리에 저장

4. 필요한 경우, 플래그(조건 코드) 업데이트
    - 명령어 실행 결과에 따라 CPU 상태를 변경하는 플래그(Flags)를 설정할 수도 있음.
    - 예: 어떤 연산 결과가 0이면, "Zero Flag"를 설정해서 나중에 분기(조건문)할 때 사용할 수 있음.

- 위 사이클의 결과
    - CPU가 명령어를 실행하고, 연산 결과를 저장하거나 메모리에 반영함.
    - 이제 다음 명령어를 실행하기 위해 다시 Fetch 단계로 돌아감.




### 6. 전체 프로세스 정리

- CPU가 명령어를 처리하는 과정은 전체적으로 아래와 같음.

1. Fetch (명령어 가져오기)
    - PC → MAR (명령어 주소 저장)
    - MAR → MBR (메모리에서 명령어 읽어오기)
    - MBR → IR (명령어 저장 후 PC 증가)

2. Decode (명령어 해석하기)
    - IR에서 Opcode 분석
    - 연산인지, 메모리 접근인지 판단

3. Execute (명령어 실행하기)
    - ALU에서 연산 수행
    - 메모리에서 데이터 읽기/쓰기
    - 결과 저장

4. 그리고 다시 Fetch 단계로 돌아가서 다음 명령어를 실행




### 7. 요약

- CPU가 명령어를 실행하는 과정은 결국 "Fetch => Decode => Execute"를 반복하는 것
- 이 과정에서 여러 레지스터들이 협력해서 CPU가 프로그램을 실행할 수 있도록 도와줌.




### 8. 참고 링크

- [깃헙레포](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Computer%20Architecture/%EB%AA%85%EB%A0%B9%EC%96%B4%20Cycle.md#%EB%AA%85%EB%A0%B9%EC%96%B4-cycle)
