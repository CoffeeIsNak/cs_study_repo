# REST API 정리

### 1. API

- API (Application Programming Interface): API는 응용 프로그램(소프트웨어) 간의 통신을 가능하게 하는 인터페이스를 의미


1) API의 역할

- 서로 다른 소프트웨어가 데이터를 주고받을 수 있도록 규칙을 정의함.

- 클라이언트와 서버, 또는 다른 서비스 간에 데이터를 교환하는 방식 제공.

- 개발자가 특정 기능을 재사용하거나 확장할 수 있도록 지원.


2) API의 주요 구성 요소

- API는 보통 요청(Request)과 응답(Response) 구조로 이루어짐.

- 엔드포인트(Endpoint): API가 제공하는 URL 주소 (예: https://api.example.com/users)

- 메서드(Method): 요청의 목적을 정의 (예: GET, POST, PUT, DELETE)

- 요청(Request): 클라이언트가 서버에 보내는 데이터

- 응답(Response): 서버가 클라이언트에 보내는 데이터

- 헤더(Header): 요청과 응답에 포함되는 메타데이터 (예: 인증 정보, 데이터 형식)

- 바디(Body): 주고받는 데이터 내용 (JSON, XML 등)




### 2. REST API란?

- REST (REpresentational State Transfer): REST는 2000년 Roy Fielding이 제안한 웹 기반 API 설계 원칙, HTTP 프로토콜을 기반으로 API를 설계하는 방식을 말함.


1) REST의 핵심 원칙

- REST API는 다음 6가지 원칙을 만족해야 함.

1. 클라이언트-서버 구조 (Client-Server Architecture): 클라이언트와 서버를 분리하여 독립적인 개발 가능

2. 무상태성 (Stateless): 각 요청은 독립적이며, 서버는 요청 간의 상태를 저장하지 않음

3. 캐시 처리 (Cacheable): API 응답을 캐시 가능하도록 설계해 성능 최적화

4. 계층적 시스템 (Layered System): API 아키텍처는 여러 계층으로 구성 가능 (로드 밸런서, 인증 서버 등)

5. 일관된 인터페이스 (Uniform Interface): API는 일관된 URI, HTTP 메서드, 응답 형식을 유지해야 함

6. 코드 온 디맨드 (Code on Demand, 선택적): API가 클라이언트에 실행 가능한 코드를 전달할 수도 있음 (예: JavaScript)




### 3. REST API 설계 규칙

1) RESTful API의 구성 요소

- RESTful API를 설계할 때는 HTTP 메서드, 리소스 URL, 응답 형식을 잘 정의해야 한다고 함.


2) HTTP 메서드와 역할

- REST API에서는 HTTP 메서드를 사용해 자원의 상태를 조작합니다.

1. GET: 데이터를 조회
    - GET /users (모든 사용자 조회)

2. POST: 새로운 데이터 생성
    - POST /users (새 사용자 등록)

3. PUT: 기존 데이터를 전체 수정
    - PUT /users/1 (ID가 1인 사용자 정보 수정)

4. PATCH: 기존 데이터 일부 수정
    - PATCH /users/1 (ID가 1인 사용자 일부 정보 수정)

5. DELETE: 데이터를 삭제
    - DELETE /users/1 (ID가 1인 사용자 삭제)




### 5. REST API의 장점과 단점

1) 장점

- 클라이언트-서버 분리: 프론트엔드와 백엔드를 독립적으로 개발 가능

- 무상태성: 각 요청이 독립적이므로 확장성과 유지보수성이 뛰어남

- 캐시 활용 가능: 성능 최적화 가능

- 표준화된 규칙: RESTful API의 규칙을 따르면 누구나 쉽게 이해하고 사용할 수 있음


2) 단점

- 오버헤드 (Overhead): HTTP 요청/응답의 헤더가 포함되어 있어 데이터 크기가 클 수 있음

- 상태 저장 어려움: 무상태성으로 인해 로그인 세션 같은 상태를 저장하려면 추가적인 작업이 필요함

- 실시간 처리 어려움: WebSocket이나 gRPC보다 실시간 데이터 처리에 불리함




### 6. REST API vs. 기타 API 스타일

- REST API
    - 프로토콜: HTTP
    - 데이터 형식: JSON, XML
    - 메시지 크기: 가벼움
    - 설계 방식: 자원 중심
    - 실시간 처리: 제한적
    - 유연성: 보통

- SOAP API
    - 프로토콜: HTTP, SMTP
    - 데이터 형식: XML
    - 메시지 크기: 무거움
    - 설계 방식: 프로토콜 중심
    - 실시간 처리: X
    - 유연성: 낮음

- gRPC
    - 프로토콜: HTTP/2
    - 데이터 형식: Protobuf
    - 메시지 크기: 매우 가벼움
    - 설계 방식: 함수 호출 방식
    - 실시간 처리: O
    - 유연성: 높음

- GraphQL
    - 프로토콜: HTTP
    - 데이터 형식: JSON
    - 메시지 크기: 중간
    - 설계 방식: 클라이언트 주도형
    - 실시간 처리: O
    - 유연성: 매우 높음




### 7. REST API 개발 시 고려해야 할 사항

1) 보안

- HTTPS 사용: API는 항상 HTTPS 프로토콜을 사용해야 함.

- JWT 토큰 기반 인증: OAuth 2.0 또는 JWT 토큰을 활용한 인증 및 권한 관리.

- CORS 정책 설정: 허용된 도메인에서만 API 요청을 보낼 수 있도록 설정.


2) 성능 최적화

- 페이징 (Pagination): 한 번에 많은 데이터를 불러오는 대신 limit과 offset을 사용.

- 캐싱 (Caching): ETag, Cache-Control 등의 HTTP 헤더를 활용해 불필요한 요청 감소.

- Rate Limiting: 특정 시간 동안 API 요청 횟수를 제한해 DoS 공격 방지.

- FastAPI, Flask, Django REST Framework(DRF) 같은 프레임워크를 사용할 수 있음.




### 8. 추가 자료

- 웹 상에서 REST는 HTTP URI와 Method로 자원들을 구분하여 표현한 상태를 클라이언트와 서버가 서로 전송을 주고 받아 CRUD 작업을 진행하는 것을 말함
    - 이런 인터페이스를 사용자가 활용할 수 있도록 구축해둔 것이 REST API라고 할 수 있음

- RESTful: REST API를 제공하는 웹 서비스를 RESTful하다고 말할 수 있다. 설계 규칙에 맞게 통용되는 일관된 컨벤션을 유지하며 API의 이해도를 높여주는 것이 중요하다.

- REST가 필요한 이유: 
    - 이젠 웹 서버에서 웹 브라우저, 안드로이드, IOS 등 다양한 멀티 플랫폼에서 통신을 지원할 수 있어야 한다. 
    - 이에 필요한 아키텍처로 REST가 통용되기 시작했으며, 다양한 클라이언트를 대응할 수 있게 되었다. 
    - 장점은 HTTP 프로토콜 인프라를 사용하여 추가 인프라 구축이 필요 없고, API 메시지 의미가 명확하므로 이해도가 높아지며, 클라이언트와 서버의 의존도를 낮출 수 있다.

- Request 예시
    - 요청 URL 정보 + HTTP 버전
    - 웹 브라우저 종류
    - 데이터 타입
    - 쿠키 정보
    - 요청 도메인 및 경유지

```sh
GET /index.html HTTP/1.1
user-agent: MSIE 6.0; Window NT 5.0
accept: test/html; */*
cookie:name=value
refere: http://abc.com
host: www.abc.com
```

- Response 예시
    - HTTP 버전 및 응답 코드
    - 웹 서버 종류
    - 데이터 타입
    - HTTP BODY 사이즈
    - HTTP BODY 컨텐츠

```sh
HTTP/1.1 200 OK
Server: Apache
Content-type: text/html
Content-length : 1593
<html><head>.....
```

- STATUS CODE
    - 100번대 (정보전송 임시 응답) : 전송 프로토콜 수준의 정보 교환 (요청 후 프로세스 계속 진행)
    - 200번대 (성공) : 클라어인트 요청이 성공적으로 수행됨
    - 300번대 (리다이렉트) : 클라이언트는 요청을 완료하기 위해 추가적인 행동을 취해야 함(변경된 url)
    - 400번대 (클라이언트 에러) : 클라이언트의 잘못된 요청
    - 500번대 (서버 에러) : 서버쪽 오류로 인한 상태코드

- REST에 사용하는 HTTP 메소드
    - GET: 요청된 URI의 정보 응답
    - POST: 요청된 자원 생성
    - PUT: 요청된 자원 (전체) 갱신
    - DELETE: 요청된 자원 삭제
    - HEAD: 요청된 URI 정보 응답(단, 바디 제외 헤더만)
    - PATCH: 요청된 자원 (해당 자원만) 수정
    - CONNECT: 프록시 기능 요청시 사용 => 클라이언트 - 서버 SSL 핸드 쉐이크 
    - TRACE: 루프백 메시지 호출 시 사용 => 요청이 서버까지 도달하는 과정에서 어떤 프록시 또는 게이트웨이를 거쳤는지 확인하는 용도로 사용, 클라이언트가 보낸 요청이 변경되지 않았는지 확인하는 디버깅 용도로 네트워크 경로 및 중간 서버(프록시, 게이트웨이 등) 확인 가능 => 서버가 받은 원본 요청을 그대로 클라이언트에 반환함 (루프백 메시지), 보안 문제로 인해 대부분의 최신 웹 서버에서는 비활성화됨
    - OPTIONS: 메소드 종류 확인


- CONNECT 메소드: 주로 HTTPS(SSL/TLS 암호화가 적용된) 요청을 처리할 때 사용됨.
    - 클라이언트가 CONNECT 요청을 보내면, 프록시 서버는 대상 서버와 터널(Tunnel)을 형성
    - 이후 클라이언트는 프록시 서버를 통해 암호화된 SSL/TLS 통신을 직접 수행 가능해짐.
    - SSL/TLS 핸드셰이크(Handshake)는 HTTPS(SSL/TLS 암호화) 연결을 설정하는 과정
    - 클라이언트(웹 브라우저)와 서버가 보안 키(암호화 키)를 교환하고 보안 채널을 형성하는 역할
    - 핸드셰이크 과정: 
        - 1. 클라이언트 요청: 클라이언트(웹 브라우저)가 "HTTPS 사이트에 접속하고 싶어요" 라고 프록시에게 요청 (CONNECT)
        - 2. 프록시 서버가 대상 서버와 연결 시도: 프록시 서버는 대상 서버에 TCP 연결을 생성. => 연결이 성공하면 200 Connection Established 응답을 보냄.
        - 3. 클라이언트-서버 SSL/TLS 핸드셰이크 진행: 이후, 클라이언트와 대상 서버는 프록시를 통해 암호화된 SSL/TLS 핸드셰이크를 수행. => 프록시는 이 과정에 개입하지 않고 단순히 데이터만 전달함 (즉, "터널 역할" 수행). => 핸드셰이크가 완료되면, HTTPS(SSL/TLS 암호화된) 데이터가 클라이언트와 서버 사이에서 오간다.
    - 일반적으로 HTTP 프록시는 클라이언트와 서버 간의 요청을 해석하고 변경할 수 있지만, HTTPS 요청은 암호화되어 있기 때문에 프록시가 내용을 볼 수 없음 => 따라서 프록시는 CONNECT 메서드를 사용하여 터널을 형성하고, 클라이언트와 서버가 직접 SSL/TLS 통신을 할 수 있도록 중간에서 연결만 전달하는 역할을 수행해줌.
    - 주로 기업 네트워크의 보안 정책, VPN, 프록시 서버를 통한 우회 접속 등에 사용됨.
    - 활용 사례
        - HTTPS 프록시 서버: 사내 네트워크에서 외부 인터넷 연결을 제한하는 경우 사용.
        - VPN 서비스: CONNECT를 사용해 프록시를 통해 인터넷을 우회 접속.
        - MITM (Man-in-the-Middle) 공격 시도: 악성 프록시 서버가 CONNECT 요청을 가로채서 SSL/TLS 트래픽을 탈취할 수도 있음.

- 서비스 시 지원해야 할 메소드 종류: GET, POST, HEAD, OPTIONS
    - 나머지 메소드는 보안 취약점 야기 가능성 존재하므로 비활성화 필요
    - PUT : Web Shell을 통한 시스템 침투가 가능(파일 업로드)
    - DELETE : 클라이언트에서 웹 서버 파일 삭제 가능
    - CONNECT : HTTP 프록시 악용 가능
    - TRACE : XST 공격으로 세션 탈취 가능

- Idempotentency: 멱등성 (한 번 수행했을 때, 여러 번 수행했을 때 결과가 같은 성질)
    - 핵심 개념:
        - 안전성 (Safety): 동일한 요청을 여러 번 보내더라도, 서버의 데이터 상태에 영향을 미치지 않아야 함.
        - 반복 실행 가능 (Repeatability): 네트워크 장애 또는 클라이언트 오류로 인해 같은 요청을 다시 보냈을 때, 결과가 바뀌지 않아야 함.
        - 데이터 무결성 보장: 중복 요청이 들어오더라도 데이터가 변형되거나 잘못 저장되지 않도록 보장.
    - HTTP 메소드 마다 성립 안할 수 있음.
        - GET, PUT, DELETE: 성립 => 여러번 보내도 같은 결과를 조회, 생성, 삭제 가능
        - POST, PATCH: 성립 X => POST의 경우 리소스 중복 생성이 되거나, PATCH의 경우 부분 업데이트 하므로 다를 수 있음.

- Idempotency가 중요한 이유:
    - 네트워크 장애 대응: 클라이언트가 요청을 보냈지만 네트워크 문제가 발생하여 응답을 받지 못했을 경우, 같은 요청을 다시 보내도 문제가 발생하지 않아야 함.
    - 중복 요청 방지: 예를 들어, 결제 API에서 POST /payment를 중복 요청하면 같은 결제가 여러 번 처리될 위험이 있음. => 하지만 PUT을 사용하여 PUT /payment/{order_id}를 구현하면 같은 주문 ID에 대해 여러 번 요청해도 한 번만 처리됨.
    - 데이터 정합성 유지: 클라이언트가 여러 번 요청을 보내더라도, 데이터가 변형되지 않고 동일한 상태를 유지할 수 있도록 보장.

 Idempotency Key를 활용한 중복 방지 (POST 요청의 멱등성 확보)
멱등성이 없는 POST 요청에서 Idempotency Key를 활용하면 중복 요청 방지가 가능함.

- Idempotency Key: 클라이언트가 POST 요청을 보낼 때 고유한 키(Idempotency Key)를 함께 전송하여, 서버가 중복 요청인지 확인하는 방식.
    - 서버가 유저의 고유한 키를 저장하고, 만약 동일한 키로 요청이 다시 오면 이미 처리된 요청이라고 응답.
    - 클라이언트가 같은 요청을 다시 보냈을 때, 서버는 기존 요청을 다시 처리하지 않고, 기존의 결과를 반환.
    - 이를 통해 POST와 같은 요청도 멱등성을 보장할 수 있음.

- REST의 특징
    - Server-Client 구조
        - Server : 자원 존재 / Client : 자원 요청 => 클라이언트와 서버의 의존성 감소, 별도로 개발 가능.
    - Stateless: Client의 context를 Server에 저장하지 않음 => 구현 단순, Server는 모든 요청을 각자 별개의 것으로 인식하고 처리
    - Cacheable: HTTP의 캐싱 기능 활용 가능 => 응답 시간, 성능 빨라짐
    - Uniform Interface: 특정 언어에 종속되지 않고 HTTP 프로토콜을 따르면 모든 플랫폼에 적용 가능(Loosely Coupling)

